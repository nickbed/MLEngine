#include "Scene\Camera.h"

#define _USE_MATH_DEFINES
#include <cmath>

#include "glm\gtc\matrix_transform.hpp"
#include "glm\gtc\type_ptr.hpp"

#include <iostream>


/////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////////////////////
Camera::Camera() 

{
	//reset();
}

Camera::~Camera()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
// Get the position
/////////////////////////////////////////////////////////////////////////////////////////////
const glm::vec3& Camera::position() const
{
	return _position;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Set the position
/////////////////////////////////////////////////////////////////////////////////////////////
void Camera::setPosition(const glm::vec3& position)
{
	_position = position;
}




/////////////////////////////////////////////////////////////////////////////////////////////
// Get the fieldOfView
/////////////////////////////////////////////////////////////////////////////////////////////
float Camera::fieldOfView() const
{
	return _fieldOfView;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Set the fieldOfView
/////////////////////////////////////////////////////////////////////////////////////////////
void Camera::setFieldOfView(float fieldOfView)
{
	assert(fieldOfView>0.0f && fieldOfView <180.0f);
	_fieldOfView = fieldOfView;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Get the aspectRatio
/////////////////////////////////////////////////////////////////////////////////////////////
float Camera::aspectRatio() const
{
	return _aspectRatio;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Set the aspectRatio
/////////////////////////////////////////////////////////////////////////////////////////////
void Camera::setAspectRatio(float aspectRatio)
{
	assert(aspectRatio >0.0f);
	_aspectRatio = aspectRatio;
}


/////////////////////////////////////////////////////////////////////////////////////////////
// Get the nearPlane
/////////////////////////////////////////////////////////////////////////////////////////////
float Camera::nearPlane() const
{
	return _nearPlane;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Set the nearPlane
/////////////////////////////////////////////////////////////////////////////////////////////
float Camera::farPlane() const
{
	return _farPlane;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Set the nearPlane and the farPlane
/////////////////////////////////////////////////////////////////////////////////////////////
void Camera::setNearAndFarPlanes(float nearPlane, float farPlane)
{
	assert(nearPlane > 0.0f);
	assert(farPlane > nearPlane);
	_nearPlane = nearPlane;
	_farPlane = farPlane;
}


/////////////////////////////////////////////////////////////////////////////////////////////
// Rotate the camera
/////////////////////////////////////////////////////////////////////////////////////////////
void Camera::rotate(const float x, const float y)
{
	//Update the current _pitch and _yaw; i.e. the current x and y rotations
	_pitch += y;
	_yaw += x;

	if ((_pitch>360) || (_pitch<-360)) _pitch=0;
	if ((_yaw>360) || (_yaw<-360)) _yaw=0;


	glm::vec3 ForwardVector =  _target - _position;//Finds forwar vector
	glm::vec3 right = glm::cross(ForwardVector, glm::vec3(0,1,0));//Finds right vector
	glm::vec3 up = glm::cross(ForwardVector, right);//Finds finds relative up vector

	_position = glm::rotate(_position,-x,up);//rotates around the up, Y
	_position = glm::rotate(_position,y,right);//rotates around the right, x
	//Finally call update()
	update();
}


/////////////////////////////////////////////////////////////////////////////////////////////
// Pan the camera
/////////////////////////////////////////////////////////////////////////////////////////////
void Camera::pan(const float x, const float y)
{

	float speedX= 0.2f, speedY = 0.02f;
	glm::vec3 ForwardVector =  _target - _position;//Finds forward vector
	glm::vec3 right = glm::cross(ForwardVector, glm::vec3(0,1,0));//Finds right vector
	glm::vec3 up = glm::cross(ForwardVector, right);//Finds the relative up vector



	_position += right * x * speedX;//Translates the position in the X relative
	_target += right * x * speedX;//Translates the position in the X relative
	_position += up * y * speedY;//Translates the position in the Y relative
	_target += up * y * speedY;//Translates the position in the Y relative




	//Finally call update()
	update();
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Zoom the camera
/////////////////////////////////////////////////////////////////////////////////////////////
void Camera::zoom(const float z)
{
	float zoomSpeed =  0.05f;
	//Finally call update()
	glm::vec3 ForwardVector = _target - _position;//Finds forward vector
	_position += ForwardVector*z*zoomSpeed;//Moves in the forward vector
	_target += ForwardVector*z*zoomSpeed;//Moves in the forward vector
	update();

}

/////////////////////////////////////////////////////////////////////////////////////////////
// Update the camera
/////////////////////////////////////////////////////////////////////////////////////////////
void Camera::update()
{

	_forward = _target - _position;


	double dArray[16] = {0.0};

	
	_right = glm::cross(_up,_forward);
	glm::vec3 up = glm::normalize(glm::cross(_forward,_right));
	_view = glm::lookAt(_position,_target  ,up);

		
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Reset the camera
/////////////////////////////////////////////////////////////////////////////////////////////
void Camera::init()
{

	_pitch = 0.0f;
	_yaw = 0.0f;

	_position= glm::vec3(0.0f, 10.0f, 20.0f);
	_up= glm::vec3(0.0f,-1.0f,0.0f);
	_target = glm::vec3(0.0f,0.0f,0.0f);
	_right = glm::cross(_up,_target);
	_fieldOfView =50.0f;
	_nearPlane = 0.1f;
	_farPlane = 10000.f;
	_aspectRatio =(float)1024 / (float)768;
	_forward = _target - _pitch;

	_view = glm::lookAt(_position, glm::vec3(0.0f,1.0f,0.0f), glm::vec3(0.0f,-1.0f,0.0f));
	_projection = glm::perspective(_fieldOfView,_aspectRatio,_nearPlane,_farPlane);

	
}
void Camera::lookAt(const glm::vec3& lookAt)
{
	_target = lookAt;
}
void Camera::setPitch(float pitch)
{
	_pitch = pitch;
}
void Camera::setYaw(float yaw)
{
	_yaw = yaw;
}
/////////////////////////////////////////////////////////////////////////////////////////////
// Return the camera View matrix
/////////////////////////////////////////////////////////////////////////////////////////////
glm::mat4 Camera::view() 
{

	this->update();
	return _view;
}


/////////////////////////////////////////////////////////////////////////////////////////////
// Return the camera Projection matrix
/////////////////////////////////////////////////////////////////////////////////////////////
glm::mat4 Camera::projection() 
{
	this->update();
	return _projection;
}